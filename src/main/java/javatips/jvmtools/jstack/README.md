# 找到线程 ID

```bash
top -Hp <PID>

```

# 线程状态

- 新建（NEW）：表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。
- 就绪（RUNNABLE）：表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。
- 在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。
- 阻塞（BLOCKED）：这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。
- 等待（WAITING）：表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。
- 计时等待（TIMED_WAIT）：其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本。
- 终止（TERMINATED）：不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。

# Thread StackTrace State

- `Deadlock`：死锁 (重点关注)
- `Runnable`：执行中。该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正
  在运行。
- `Waiting on condition`：等待资源 (重点关注)
- `Waiting on monitor entry`：等待获取监视器线程处于等待获取监视器的状态 (重点关注)
- `in Object.wait()` 或 `TIMED_WAITING`：对象等待中。线程获取到监视器后发现条件不满足调用 `wait()`方法，放弃监视器。
- `Suspended`：暂停
- `Blocked`：阻塞 (重点关注)
- `Parked`：停止

# JVM 内部后台线程

| 线程名称                              |     | 详细说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|:--------------------------------- |:---:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Attach Listener`                 |     | `Attach Listener` 线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。<br/>通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。                                                                                                                                                                                                                                                                                                    |
| `Signal Dispatcher`               |     | 前面我们提到第一个 Attach Listener 线程的职责是接收外部 jvm 命令，当命令接收成功后，会交给 signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 <br/>signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。                                                                                                                                                                                                                                                                                                             |
| `CompilerThread0`                 |     | 用来调用JITing，实时编译装卸class 。<br/>通常，jvm会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：`CompilerThread1`                                                                                                                                                                                                                                                                                                                                                                                |
| `Concurrent Mark-Sweep GC Thread` |     | 并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。<br/>ps：启用该垃圾回收器，需要在jvm启动参数中加上：`-XX:+UseConcMarkSweepGC`                                                                                                                                                                                                                                                                                                                                                               |
| `DestroyJavaVM`                   |     | 执行 `main()` 的线程在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程。JVM 在 Jboss 服务器启动之后，就会唤起DestroyJavaVM 线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载 JVM。线程退出时，都会判断自己当前是否是整个JVM中最后一个非 deamon 线程，如果是，则通知 DestroyJavaVM 线程卸载 JVM。                                                                                                                                                                                                                                  |
| `Finalizer`                       |     | 这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法。<br/>关于Finalizer线程的几点：<br/>1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；<br/>2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；<br/>3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；<br/>4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难； |
| `Gang worker#0`                   |     | JVM 用于做新生代垃圾回收（monir gc）的一个线程。`#` 号后面是线程编号，例如：`Gang worker#1`                                                                                                                                                                                                                                                                                                                                                                                                        |
| `GC Daemon`                       |     | GC Daemon 线程是JVM为RMI提供远程分布式 GC 使用的，GC Daemon线程里面会主动调用 `System.gc()` 方法，对服务器进行 Full GC。 其初衷是当 RMI 服务器返回一个对象到其客户机（远程方法的调用方）时，其跟踪远程对象在客户机中的使用。<br/>当再没有更多的对客户机上远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。不过，我们现在 jvm 启动参数都加上了 `-XX:+DisableExplicitGC` 配置，所以，这个线程只有打酱油的份了。                                                                                                                                                                                              |
| `Reference Handler`               |     | JVM 在创建 main 线程后就创建 `Reference Handler` 线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。                                                                                                                                                                                                                                                                                                                                                                            |
